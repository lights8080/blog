---
title: 凤凰架构-架构安全性
categories:
  - 读书笔记
  - 技术
tags:
  - 凤凰架构
abbrlink: ac30aed0
date: 2021-10-21 00:00:00
---

周志明《凤凰架构：构建可靠的大型分布式系统》
https://icyfenix.cn/

包括：认证、授权、凭证、保密、传输、验证

<!-- more -->

系统安全，不仅包括“防御系统被黑客攻击”这样狭隘的安全，还包括一些与管理、运维、审计等领域主导的相关安全性问题，比如说安全备份与恢复、安全审计、防治病毒，等等。

软件架构安全，主要包括（但不限于）以下这些问题的具体解决方案：认证、授权、凭证、保密、传输、验证。

这些问题基本上也都是与具体系统、具体业务无关的通用性问题，这就意味着它们往往会存在一些业界通行的、已经被验证过是行之有效的解决方案，乃至已经形成了行业标准，不需要我们再从头去构思如何解决。

## 认证（Authentication）
> 系统如何正确分辨出操作用户的真实身份？

认证（Authentication）、授权（Authorization）和凭证（Credentials）这三项可以说是一个系统中最基础的安全设计了。
信息系统在为用户提供服务之前，总是希望先弄清楚“你是谁？”（认证）、“你能干什么？”（授权）以及“你如何证明？”（凭证）这三个基本问题的答案。

架构安全性的经验原则：以标准规范为指导、以标准接口去实现，严格遵循标准就是最恰当的安全设计。

#### 基于通讯协议：HTTP 认证
IETF 在RFC 7235中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，当未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时要在响应报文头里，附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取哪种方式，产生能代表访问者身份的凭证信息：
```
WWW-Authenticate: <认证方案> realm=<保护区域的描述信息>
Proxy-Authenticate: <认证方案> realm=<保护区域的描述信息>
```
客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden。
```
Authorization: <认证方案> <凭证内容>
Proxy-Authorization: <认证方案> <凭证内容>
```

*HTTP 认证框架提出的认证方案，是希望能把认证“要产生身份凭证”的目的，与“具体如何产生凭证”的实现给分开来。*

认证方案：
* Basic：是一种以演示为目的的认证方案，Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。
* Digest：HTTP 摘要认证，可以把它看作是 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐后，再通过 MD5/SHA 等哈希算法取摘要发送出去。
* Bearer：基于 OAuth 2.0 规范来完成认证，OAuth 2.0 是一个同时涉及到认证与授权的协议。
* HOBA：一种基于自签名证书的认证方案。
* 其他：很多厂商也扩展了自己的认证方案，如AWS4-HMAC-SHA256、Twitter Basic等。

#### 基于通讯内容：Web 认证
但目前的信息系统，直接采用 HTTP 认证框架的比例其实是非常低的。以 HTTP 协议为基础的认证框架，也只能面向传输协议而不是具体传输内容来设计。

如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。

这种依靠内容而不是传输协议来实现的认证方式，被称为“Web 认证”，由于在实现形式上，登录表单占了绝对的主流，因此它通常也被称为“表单认证”。

*表单认证与 HTTP 认证不见得是完全对立的，它们分别有不同的关注点，可以结合使用。*

#### WebAuthn
万维网联盟批准了由FIDO（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准“WebAuthn”。

Web 表单长什么样，没有什么行业标准可循，允许做的五花八门，用户名密码、扫码、图形验证码等，都可以自行决定认证的全套交互细节。这些登录表单提交之前进行必要的表单校验，确实不太可能定义在规范上。
所以，WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证。


## 授权（ Authorization）
> 系统如何控制一个用户该看到哪些数据、能操作哪些功能？

授权涉及到两个相对独立的问题
1）确保授权的过程可靠，主要有OAuth 2.0 和 SAML 2.0
2）确保授权的结果可控，对资源的访问控制模型，主要有RBAC、ABAC

### OAuth 2.0
OAuth 2.0 解决的是第三方服务中涉及的安全授权问题，是面向于解决第三方应用（Third-Party Application）的认证授权协议。

可参考阮一峰老师讲解：https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html

OAuth 2.0 提出了四种不同的授权方式，包括授权码模式、简化模式、密码模式、客户端模式。
#### 授权码模式（Authorization Code）
授权码模式是四种模式中最严谨的，第三方应用必须有应用服务器，要求服务器地址必须与注册时提供的地址一致。
先发放授权码，然后第三方服务器使用授权码获取令牌，避免令牌在传输转向过程中被泄漏的风险。 

![授权码模式，简易流程图](https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/NCzNMZ.png)

#### 简化模式（Implicit）
隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持。授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了。

特别强调了令牌必须是“通过 Fragment 带回”的，Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。
尽最大努力地避免了令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。

#### 密码模式（Resource Owner Password Credentials）
密码模式里，认证和授权就被整合成了同一个过程。仅限于在用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。

#### 客户端模式（Client Credentials）
在微服务架构中，其实并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间的调用也需要先进行认证授权，然后才能通讯。客户端模式便是一种常用的服务间认证授权的解决方案。

### RBAC（基于角色的访问控制，Role-Based Access Control）。
所有的访问控制模型，实质上都是在解决同一个问题：谁（User）拥有什么权限（Authority）去操作（Operation）哪些资源（Resource）。

为避免对每一个用户设定权限，RBAC 提出了角色和许可等概念，角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。
RBAC-1 模型的角色权限继承关系，RBAC-2 模型的角色职责分离关系。

建立访问控制模型的基本目的就是为了管理垂直权限和水平权限。垂直权限即功能权限，水平权限则是数据权限，它很难抽象与通用。

## 凭证（Credentials）
> 系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？

### Cookie-Session
Set-Cookie 指令：这个指令的含义是以键值对的方式向客户端发送一组信息，在此后一段时间内的每次 HTTP 请求中，这组信息会附带着名为 Cookie 的 Header 重新发回给服务端，以便服务器区分来自不同客户端的请求。

Cookie-Session 也就是最传统的，但在今天依然广泛应用于大量系统中的、由服务端与客户端联动来完成的状态管理机制。

Cookie-Session 的优点是，实现足够简单，服务端有主动的状态管理的能力，适用于单节点的单体服务环境中。缺点是，服务器水平扩展成多节点时，状态管理收到存在CAP的局限。

### JWT（JSON Web Token）
解决认证授权问题的无状态方案。是目前广泛使用的一种令牌格式，尤其经常与 OAuth 2.0 配合应用于分布式的、涉及多方的应用系统中。

JWT 默认的签名算法 HMAC SHA256 是一种带密钥的哈希摘要算法，加密与验证过程都只能由中心化的授权服务来提供，所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用。
在多方系统，或者是授权服务与资源服务分离的分布式应用当中，通常会采用非对称加密算法来进行签名。这时候，除了授权服务端持有的可以用于签名的私钥以外，还会对其他服务器公开一个公钥。
不过，这个公钥不能用来签名，但它能被其他服务用于验证签名是否由私钥所签发的。这样，其他服务器就也能不依赖授权服务器、无需远程通讯，即可独立判断 JWT 令牌中的信息的真伪了。

JWT 只解决防篡改的问题，并不解决防泄露的问题，所以令牌默认是不加密的，需要时自行实现。JWT 缺点有：令牌难以主动失效，相对更容易遭受重放攻击，只能携带相当有限的数据，必须考虑令牌在客户端如何存储。

## 保密（Confidentiality）
> 系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？

根据需要保密信息所处的不同环节，将其划分为“信息在客户端时的保密”，“信息在传输时的保密”和“信息在服务端时的保密”。

保密的强度：(逐步升级的保密措施，更高的安全强度同时也意味着要付出更多的代价)
1. 以摘要代替明文：不能防止弱密码被彩虹表攻击
2. 先加盐值再做哈希是应对弱密码的常用方法：不能阻止加密结果被监听
3. 将盐值变为动态值能有效防止冒认：协商出盐值的过程将变得极为复杂，每次协商只能保护一次操作
4. 加入动态令牌防止重放攻击：流量公共位置建立校验逻辑，服务器要付出分发令牌信息代价
5. 启用 HTTPS 来应对因嗅探而导致的信息泄露问题：客户端或服务端被攻破风险
6. 进一步提升保密强度的不同手段：独立于客户端存储的物理设备-U盾、独立于网络的信息通道-手机验证码、与公网物理隔离的专用内部网络

### 信息在客户端时的保密
为了保证信息不被黑客窃取而去做客户端加密，其实没有太大意义，对绝大多数的信息系统来说，启用 HTTPS 可以说是唯一的实际可行的方案。

但是！为了保证密码不在服务端被滥用（密码明文被写入数据库、被输出到日志中），而在客户端就开始加密的做法，还是很有意义的。

客户端无论是否动态加盐，都不可能代替 HTTPS。真正防御性的密码加密存储应该在服务端中进行，但这是为了防御服务端被攻破而批量泄露密码的风险，并不是为了增强传输过程的安全性。

客户端并不提倡在盐值上做动态化，更理想的方式是引入慢哈希函数来解决，增加破解密码的难度。
如果我们控制BCrypt的执行时间大概是 0.1 秒完成一次哈希计算的话，要算完所有的 10 位大小写字母和数字组成的弱密码，就大概需要 P(26*2+10,10)/(3600*24*365)/0.1=1,237,204,169 年的时间。

### 信息在客户端时的保密
“普通安全强度”的意思是，在具有一定保密安全性的同时，避免消耗过多的运算资源，这样验证起来也相对便捷。毕竟对多数信息系统来说，只要配合一定的密码规则约束，比如密码要求长度、特殊字符等等，再配合 HTTPS 传输，就已经足够防御大多数风险了。即使是用户采用了弱密码、客户端通讯被监听、服务端被拖库、泄露了存储的密文和盐值等问题同时发生，也能够最大限度地避免用户明文密码被逆推出来。

防御服务端被拖库后，针对固定盐值的批量彩虹表攻击。具体做法是为每一个密码（指客户端传来的哈希值）产生一个随机的盐值。（建议使用CSPRNG来生成一个长度与哈希值相等的随机字符串）

把动态盐值混入客户端传来的哈希值，再做一次哈希，产生出最终的密文。
把“最终的密文”和“随机的盐值”一起写入到数据库记录中。
服务端验证过程，取出登录用户对应的密文和盐值，采用相同的哈希算法，针对客户端传来的哈希值、服务端存储的盐值计算摘要结果，比较结果和数据库储存的“最终的密文”是否相同。

## 传输（Transport Security）
> 系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？

摘要与加密和签名的本质区别：
![摘要、对称机密、非对称加密的区别](https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/87Lb7x.jpg)

非对称加密算法：
公钥加密，私钥解密，这种就是加密：向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。
私钥加密，公钥解密，这种就是签名：防止私钥所有者发布的内容被篡改，不用来保证内容不被他人获得。

What is a Digital Signature?
http://www.youdzone.com/signature.html

## 验证（Verification）
> 系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？

Java Bean Validation。是比较提倡的做法，那就是把校验行为从分层中剥离出来，不是在哪一层做，而是在 Bean 上做。

采用 Bean Validation 也便于我们统一处理校验结果不满足时的提示信息。比如提供默认值、提供国际化支持（这里没做）、提供统一的客户端返回格式（创建一个用于 ConstraintViolationException 的异常处理器来实现），以及批量执行全部校验。

对于 Bean 与 Bean 校验器，两条关于编码的建议：
第一条建议是，要对校验项预置好默认的提示信息，这样当校验不通过时，用户能获得明确的修正提示。
第二条建议是，要把不带业务含义的格式校验注解放到 Bean 的类定义之上，把带业务逻辑的校验放到 Bean 的类定义的外面。