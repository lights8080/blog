---
title: 凤凰架构-架构安全性
categories:
  - 读书笔记
  - 技术
tags:
  - 凤凰架构
date: 2021-10-21
---

周志明《凤凰架构：构建可靠的大型分布式系统》
https://icyfenix.cn/

包括：认证、授权、凭证、保密、传输、验证

<!-- more -->

系统安全，不仅包括“防御系统被黑客攻击”这样狭隘的安全，还包括一些与管理、运维、审计等领域主导的相关安全性问题，比如说安全备份与恢复、安全审计、防治病毒，等等。

软件架构安全，主要包括（但不限于）以下这些问题的具体解决方案：认证、授权、凭证、保密、传输、验证。

这些问题基本上也都是与具体系统、具体业务无关的通用性问题，这就意味着它们往往会存在一些业界通行的、已经被验证过是行之有效的解决方案，乃至已经形成了行业标准，不需要我们再从头去构思如何解决。

## 认证（Authentication）
> 系统如何正确分辨出操作用户的真实身份？

认证（Authentication）、授权（Authorization）和凭证（Credentials）这三项可以说是一个系统中最基础的安全设计了。
信息系统在为用户提供服务之前，总是希望先弄清楚“你是谁？”（认证）、“你能干什么？”（授权）以及“你如何证明？”（凭证）这三个基本问题的答案。

架构安全性的经验原则：以标准规范为指导、以标准接口去实现，严格遵循标准就是最恰当的安全设计。

#### 基于通讯协议：HTTP 认证
IETF 在RFC 7235中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，当未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时要在响应报文头里，附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取哪种方式，产生能代表访问者身份的凭证信息：
```
WWW-Authenticate: <认证方案> realm=<保护区域的描述信息>
Proxy-Authenticate: <认证方案> realm=<保护区域的描述信息>
```
客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden。
```
Authorization: <认证方案> <凭证内容>
Proxy-Authorization: <认证方案> <凭证内容>
```

*HTTP 认证框架提出的认证方案，是希望能把认证“要产生身份凭证”的目的，与“具体如何产生凭证”的实现给分开来。*

认证方案：
* Basic：是一种以演示为目的的认证方案，Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。
* Digest：HTTP 摘要认证，可以把它看作是 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐后，再通过 MD5/SHA 等哈希算法取摘要发送出去。
* Bearer：基于 OAuth 2.0 规范来完成认证，OAuth 2.0 是一个同时涉及到认证与授权的协议。
* HOBA：一种基于自签名证书的认证方案。
* 其他：很多厂商也扩展了自己的认证方案，如AWS4-HMAC-SHA256、Twitter Basic等。

#### 基于通讯内容：Web 认证
但目前的信息系统，直接采用 HTTP 认证框架的比例其实是非常低的。以 HTTP 协议为基础的认证框架，也只能面向传输协议而不是具体传输内容来设计。

如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。

这种依靠内容而不是传输协议来实现的认证方式，被称为“Web 认证”，由于在实现形式上，登录表单占了绝对的主流，因此它通常也被称为“表单认证”。

*表单认证与 HTTP 认证不见得是完全对立的，它们分别有不同的关注点，可以结合使用。*

#### WebAuthn
万维网联盟批准了由FIDO（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准“WebAuthn”。

Web 表单长什么样，没有什么行业标准可循，允许做的五花八门，用户名密码、扫码、图形验证码等，都可以自行决定认证的全套交互细节。这些登录表单提交之前进行必要的表单校验，确实不太可能定义在规范上。
所以，WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证。


## 授权（ Authorization）
> 系统如何控制一个用户该看到哪些数据、能操作哪些功能？

授权涉及到两个相对独立的问题
1）确保授权的过程可靠，主要有OAuth 2.0 和 SAML 2.0
2）确保授权的结果可控，对资源的访问控制模型，主要有RBAC、ABAC

### OAuth 2.0
OAuth 2.0 解决的是第三方服务中涉及的安全授权问题，是面向于解决第三方应用（Third-Party Application）的认证授权协议。

可参考阮一峰老师讲解：https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html

OAuth 2.0 提出了四种不同的授权方式，包括授权码模式、简化模式、密码模式、客户端模式。
#### 授权码模式（Authorization Code）
授权码模式是四种模式中最严谨的，第三方应用必须有应用服务器，要求服务器地址必须与注册时提供的地址一致。
先发放授权码，然后第三方服务器使用授权码获取令牌，避免令牌在传输转向过程中被泄漏的风险。 

![授权码模式，简易流程图](https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/NCzNMZ.png)

#### 简化模式（Implicit）
隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持。授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了。

特别强调了令牌必须是“通过 Fragment 带回”的，Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。
尽最大努力地避免了令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。

#### 密码模式（Resource Owner Password Credentials）
密码模式里，认证和授权就被整合成了同一个过程。仅限于在用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。

#### 客户端模式（Client Credentials）
在微服务架构中，其实并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间的调用也需要先进行认证授权，然后才能通讯。客户端模式便是一种常用的服务间认证授权的解决方案。

### RBAC（基于角色的访问控制，Role-Based Access Control）。
所有的访问控制模型，实质上都是在解决同一个问题：谁（User）拥有什么权限（Authority）去操作（Operation）哪些资源（Resource）。

为避免对每一个用户设定权限，RBAC 提出了角色和许可等概念，角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。
RBAC-1 模型的角色权限继承关系，RBAC-2 模型的角色职责分离关系。

建立访问控制模型的基本目的就是为了管理垂直权限和水平权限。垂直权限即功能权限，水平权限则是数据权限，它很难抽象与通用。

## 凭证（Credentials）
> 系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？


## 保密（Confidentiality）
> 系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？


## 传输（Transport Security）
> 系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？


## 验证（Verification）
> 系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？


