---
title: 凤凰架构-本地事务
categories:
  - 读书
  - 技术
tags:
  - 凤凰架构
  - 事务
abbrlink: 4bfa4595
date: 2021-07-30 00:00:00
---

周志明《凤凰架构：构建可靠的大型分布式系统》
https://icyfenix.cn/

包括：ACID、如何实现原子性和持久性、如何实现隔离性、事务隔离级别、多版本并发控制-MVCC、悲观锁和乐观锁
<!-- more -->

## 事务处理
* 一致性（Consistency）：保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾。
* 原子性（Atomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。
* 隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。
* 持久性（Durability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。

原子性，隔离性和持久性是数据库的属性，是手段，而一致性（在ACID意义上）是应用程序的属性，是目的。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。


本地事务是最基础的一种事务处理方案，通常只**适用于单个服务使用单个数据源的场景**，它是直接依赖于数据源（通常是数据库系统）本身的事务能力来工作的。

## 如何实现原子性和持久性
实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的（比如要写入到不同的磁盘块上），不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。

**未提交事务，写入后崩溃**，要将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证原子性。
**已提交事务，写入前崩溃**，要将没来得及写入磁盘的数据重新写入，以保证持久性。

由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为“崩溃恢复”。

为了能够顺利地完成崩溃恢复，会以日志的形式先记录到磁盘，日志记录全部落盘后为Commit Record，表示事务成功。根据日志上的信息对真正的数据进行修改，修改完成后为End Record，表示事务已完成持久化。这种事务实现方法被称为Commit Logging。

Commit Logging的原理很清晰，但缺陷是，即使磁盘 I/O 有足够空闲、即使某个事务修改的数据量非常庞大，都不允许在事务提交前就修改磁盘上的真实数据，这对提升数据库的性能是否不利。
为了解决这个问题，ARIES提出所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。

按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况：
* FORCE：当事务提交后，要求变动数据必须同时完成写入。
* NO-FORCE：当事务提交后，不强制变动数据必须同时完成写入。
* STEAL：在事务提交前，允许变动数据提前写入。
* NO-STEAL：在事务提交前，不允许变动数据提前写入。(从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行)

从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。允许数据提前写入（NO-STEAL），有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。
从优化磁盘 I/O 的角度看，NO-FORCE + STEAL 组合的性能无疑是最高的；从算法实现与日志的角度看 NO-FORCE + STEAL 组合的复杂度无疑也是最高的。
![FORCE 和 STEAL 的四种组合关系](https://gitee.com/lights8080/lights8080-oss/raw/master/2021/07/sbc3jM.jpg)

Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL。解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。
崩溃恢复时会执行以下三个阶段的操作：分析阶段（Analysis）、重做阶段（Redo）、回滚阶段（Undo）。

## 如何实现隔离性
隔离性保证了每个事务各自读、写的数据互相独立，不会彼此影响。

串行的数据访问，具有天然的隔离性，现代数据库都提供了以下三种锁：
* 写锁（Write Lock，也叫做排他锁，简写为 X-Lock）：只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。
* 读锁（Read Lock，也叫做共享锁，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有一个事务加了读锁，那可以直接将其升级为写锁，然后写入数据。
* 范围锁（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入。

**本地事务的四种隔离级别**
* 可串行化（Serializable）：隔离性级别最高，对事务所有读、写的数据全都加上读锁、写锁和范围锁即可（这种可串行化的实现方案称为 Two-Phase Lock - 2PL）。
* 可重复读（Repeatable Read）：对事务所涉及到的数据加读锁和写锁，并且一直持续到事务结束，但不再加范围锁。可重复读比可串行化弱化的地方在于幻读问题
* 读已提交（Read Committed）：对事务涉及到的数据加的写锁，会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。读已提交比可重复读弱化的地方在于不可重复读问题
* 读未提交（Read Uncommitted）：对事务涉及到的数据只加写锁，这会一直持续到事务结束，但完全不加读锁。读未提交比读已提交弱化的地方在于脏读问题

**事务隔离级别解决的问题**
* 幻读问题：事务执行的过程中，两个完全相同的范围查询得到了不同的结果集
* 不可重复读问题：在事务执行过程中，对同一行数据的两次查询得到了不同的结果
* 脏读问题：在事务执行的过程中，一个事务读取到了另一个事务未提交的数据

**多版本并发控制”（Multi-Version Concurrency Control，MVCC）**
这种“一个事务读 + 另一个事务写”的隔离问题，有一种名为“多版本并发控制”的无锁优化方案被主流的商业数据库广泛采用。

MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。

* 隔离级别是可串行化：可串行化本来的语义就是要阻塞其他事务的读取操作，与MVCC无锁优化冲突。
* 隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
* 隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。
* 隔离级别是读未提交：直接修改原始数据即可，其他事务查看数据的时候立刻可以查看到，无需版本控制。

MVCC 是只针对“读 + 写”场景的优化，如果是两个事务同时修改数据，即“写 + 写”的情况，那就没有多少优化的空间了，加锁几乎是唯一可行的解决方案，分为悲观锁和乐观锁。

* **“悲观锁（悲观并发控制）”**：认为事务之间数据存在竞争是必然情况，竞争越剧烈，性能越好。（即基于锁的并发控制，比如2PL）
* **“乐观锁（乐观并发控制）”**：认为事务之间数据存在竞争是偶然情况，竞争越剧烈，性能越差。（基本思路是提交事务前检查有没有更改，如果有就放弃修改并重试）

